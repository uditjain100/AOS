#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>

long wc_work(char *fileName, char *cwd, int num) {
	
	FILE *file = fopen(fileName, "r");
	
	int ch;
	long chars = 0;
	long words = 0;
	long lines = 0;

	while((ch = fgetc(file)) != EOF) {
		chars++;
		if(ch == '\n') lines++;
		if(ch == ' ') words++;
	}

	fclose(file);

	if(num == 0) printf("%ld ", chars);
	if(num == 1) printf("%ld ", lines);
	if(num == 2) printf("%ld ", words);

	printf("%s \n", fileName);

	if(num == 0) return chars;
	if(num == 1) return lines;
	if(num == 2) return words;
}


int isFilePresent(char *fileName, char *path) {
	DIR *dir = opendir(path);
    	struct dirent *file;
    	while ((file = readdir(dir)) != NULL)
		if(strcmp(file->d_name, fileName) == 0)
			return 1;
	return 0;
}

int main(int argc, char *argv[]) {
	int n = argc;

	char cwd[1000];
	getcwd(cwd, sizeof(cwd));

	long count = 0;
	for(int i = 2; i < n; i++) {
		char *fileName = argv[i];
		if (strcmp(argv[1], "-c") == 0) {
            		if (isFilePresent(fileName, cwd) == 0) {
                		printf("No File found named %s !!! \n", fileName);
                		continue;
            		}
            		count += wc_work(fileName, cwd, 0);
        	} else if (strcmp(argv[1], "-l") == 0) {
            		if (isFilePresent(fileName, cwd) == 0) {
                		printf("No File found named %s !!! \n", fileName);
                		continue;
            		}
            		count += wc_work(fileName, cwd, 1);
        	} else if (strcmp(argv[1], "-w") == 0) {
            		if (isFilePresent(fileName, cwd) == 0) {
                		printf("No File found named %s !!! \n", fileName);
                		continue;
            		}
            		count += wc_work(fileName, cwd, 2);
        	} else {
            		printf("Invalid Command !!!");
            		return -1;
        	}
	} 

	printf("%ld total \n", count);

	return 0;
}





#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>

void rmWork(char *fileName, int prompt) {

    if (prompt == 1) {
        char res[4];
        printf("Do you want to remove file '%s'? [y/n] ", fileName);
        if (fgets(res, sizeof(res), stdin) != NULL) {
            if (res[0] == 'y' || res[0] == 'Y') {
                if (remove(fileName) != 0)
                    printf("Error in deleting file !! ");
            } 
        } else printf("Invalid input.\n");
    } else {
        if (remove(fileName) != 0)
            printf("Error in deleting file !! ");
    }

}

int isFilePresent(char *fileName, char *path) {
    DIR *dir = opendir(path);
    struct dirent *file;
    while ((file = readdir(dir)) != NULL)
        if(strcmp(file->d_name, fileName) == 0)
            return 1;
    return 0;
}

int main(int argc, char *argv[]) {
    int n = argc;

    char cwd[1024];
    getcwd(cwd, sizeof(cwd));

    int prompt = 0;
    int si = 1;

    if(n < 2) {
        printf("Invalid command !!! ");
        return -1;
    } else {

        if(strcmp(argv[1], "-i") == 0) {
            prompt = 1;
            si = 2;
        } 

        for(int i = si; i < argc; i++) {
            char *fileName = argv[i];
            if(isFilePresent(fileName, cwd) == 0) {
                printf("No File found named %s !!! \n", fileName);
                return -1;
            }

            rmWork(fileName, prompt);
        }


    }
    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>
#include <pwd.h>

void printProcesses(int showAll, int showUser, int showNotTTY, char *username)
{
    struct dirent *file;
    DIR *dir = opendir("/proc");

    if (dir == 0)
    {
        printf("Error !!");
        exit(1);
    }

    while ((file = readdir(dir)) != NULL)
    {
        char *pid = file->d_name;

        int isNumber = 1;
        for (int i = 0; pid[i] != '\0'; i++)
            if (pid[i] < '0' || pid[i] > '9')
                isNumber = 1;

        if (isNumber == 0)
            continue;

        // Terminal Attached
        char statPath[256];
        snprintf(statPath, sizeof(statPath), "/proc/%s/stat", pid);

        FILE *statFile = fopen(statPath, "r");
        if (!statFile)
            continue;

        int tty_nr;
        fscanf(statFile, "%*d %*s %*c %*d %*d %*d %*d %d", &tty_nr);
        fclose(statFile);

        if (showNotTTY == 0 && tty_nr > 0)
            continue;

        // Owner
        char statusPath[500];
        snprintf(statusPath, sizeof(statusPath), "/proc/%s/status", pid);

        FILE *statusFile = fopen(statusPath, "r");
        if (!statusFile)
            continue;

        char status[10];
        uid_t uid;
        while (fgets(status, sizeof(status), statusFile))
        {
            if (strncmp(status, "Uid:", 4) == 0)
            {
                sscanf(status, "Uid: %u", &uid);
                break;
            }
        }
        fclose(statusFile);

        struct passwd *pw = getpwuid(uid);
        char *owner = pw ? pw->pw_name : NULL;

        if (showUser == 1)
            if (owner == NULL || strcmp(owner, username) != 0)
                continue;

        // Command Name
        char command[1000];

        char commandPath[500];
        snprintf(commandPath, sizeof(commandPath), "/proc/%s/comm", pid);

        FILE *commandFile = fopen(commandPath, "r");
        if (!commandFile)
            strcpy(command, "unknown");

        fgets(command, 256, commandFile);
        command[strcspn(command, "\n")] = 0;

        fclose(commandFile);

        printf("%s\t%s\t%s\n", pid, owner, command);
    }

    closedir(dir);
}

int main(int argc, char *argv[])
{
    int n = argc;

    int showAll = 0;
    int showUser = 0;
    int showNotTTY = 1;
    char *attr = n > 1 ? argv[1] : NULL;
    char *username = n > 2 ? argv[2] : NULL;

    if (n > 3)
    {
        printf("Invalid Command !!");
        return -1;
    }

    if (n > 1)
    {
        if ((strcmp(attr, "-a") == 0 || strcmp(attr, "-e") == 0) && n != 2)
        {
            printf("Invalid Command !!");
            return -1;
        }

        if (strcmp(attr, "-a") == 0 || strcmp(attr, "-e") == 0)
            showAll = 1;
        else if (strcmp(attr, "-u") == 0 && n == 3)
            showUser = 1;

        if (strcmp(attr, "-a") == 0)
            showNotTTY = 0;
    }

    printProcesses(showAll, showUser, showNotTTY, username);
    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <grp.h>
#include <pwd.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>

void ls_a_work(char *path, int hidden) {
    DIR *dir = opendir(path);
    struct dirent *file;
    while ((file = readdir(dir)) != NULL) {
        if(hidden == 0 && file->d_name[0] == '.')
            continue;
        printf("%s\t", file->d_name);
    }
}

void ls_l_work(char *path, int hidden) {
    DIR *dir = opendir(path);
    struct dirent *file;
    while ((file = readdir(dir)) != NULL) {
        if(hidden == 0 && file->d_name[0] == '.')
            continue;

        struct stat file_stat;
        stat(path, &file_stat);

        // file type
        printf((S_ISDIR(file_stat.st_mode)) ? "d" : "-");
        printf((file_stat.st_mode & S_IRUSR) ? "r" : "-");
        printf((file_stat.st_mode & S_IWUSR) ? "w" : "-");
        printf((file_stat.st_mode & S_IXUSR) ? "x" : "-");
        printf((file_stat.st_mode & S_IRGRP) ? "r" : "-");
        printf((file_stat.st_mode & S_IWGRP) ? "w" : "-");
        printf((file_stat.st_mode & S_IXGRP) ? "x" : "-");
        printf((file_stat.st_mode & S_IROTH) ? "r" : "-");
        printf((file_stat.st_mode & S_IWOTH) ? "w" : "-");
        printf((file_stat.st_mode & S_IXOTH) ? "x" : "-");
        
        // soft links
        printf(" %lu", (unsigned long)file_stat.st_nlink);
        
        // owner
        struct passwd *pw = getpwuid(file_stat.st_uid);
        printf(" %s", pw ? pw->pw_name : "???");
        
        // group
        struct group *gr = getgrgid(file_stat.st_gid);
        printf(" %s", gr ? gr->gr_name : "???");
        
        // size
        printf(" %ld", (long)file_stat.st_size);
        
        // modification time
        char timebuf[64];
        struct tm *timeinfo = localtime(&file_stat.st_mtime);
        strftime(timebuf, sizeof(timebuf), "%b %d %H:%M", timeinfo);
        printf(" %s", timebuf);
        
        // file name
        printf(" %s\n", file->d_name);
    }
}

int main(int argc, char *argv[]) {
    int n = argc;

    char cwd[1024];
    getcwd(cwd, sizeof(cwd));

    if(n == 1)
        ls_a_work(cwd, 0);
    else if(n == 2) {
        if(strcmp(argv[1], "-l") == 0)
            ls_l_work(cwd, 0);
        else if(strcmp(argv[1], "-a") == 0)
            ls_a_work(cwd, 1);
        else {
            printf("Invalid Attribute !!! ");
            return -1;
        }
    } else {
        printf("Invalid Attribute !!! ");
        return -1;
    }
    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int n = argc;

    if (n < 2) {
        printf("Invalid Command !!");
        return -1;
    }

    int signal = SIGTERM; // 9
    int pIdx = 1;

    if (argv[1][0] == '-') {
        signal = atoi(argv[1] + 1);
        if (signal <= 0) {
            printf("Invalid signal: %s\n", argv[1]);
            return -1;
        }
        pIdx = 2; 
    }

    for (int i = pIdx; i < n; ++i) {
        pid_t pid = atoi(argv[i]);

        if (pid <= 0) {
            printf("Invalid PID: %s\n", argv[i]);
            continue;
        }

        if (kill(pid, signal) == -1) {
            printf("kill error !!");
            return -1;
        }
    }

    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>

void cat_work(char *fileName) {

	FILE *file = fopen(fileName, "r");

        int ch;
        while((ch = fgetc(file)) != EOF)
		printf("%c", ch);

        fclose(file);
}


int isFilePresent(char *fileName, char *path) {
        DIR *dir = opendir(path);
        struct dirent *file;
        while ((file = readdir(dir)) != NULL)
                if(strcmp(file->d_name, fileName) == 0)
                        return 1;
        return 0;
}

int main(int argc, char *argv[]) {

	int n = argc;

	char cwd[1000];
	getcwd(cwd, sizeof(cwd));

	for(int i = 1; i < n; i++){

		char *fileName = argv[i];

		if(isFilePresent(fileName, cwd) == 0) {
			printf("No file found named : %s \n", fileName);
			continue;
		}

		cat_work(fileName);
	}
}



#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#define MAX_PROCESSES 2
int pid[MAX_PROCESSES];
int work[MAX_PROCESSES];
int current_process = 0;
void run_process(int process_index)
{
printf("Current process = %d and work done = %d\n",
pid[process_index], work[process_index]);
work[process_index]++;
sleep(1);
}
void switch_process(int signum)
{
current_process = (current_process + 1) % MAX_PROCESSES;
alarm(1);
}
int main()
{
for (int i = 0; i < MAX_PROCESSES; i++)
{
pid[i] = i + 1;
work[i] = 0;
}
signal(SIGALRM, switch_process);
alarm(1);
while (1)
run_process(current_process);
return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

#define MAX_LINE 1000
#define MAX_ARGS 10
int main() {
  char command[MAX_LINE];
  char * tokens[MAX_ARGS];
  int input, output;
  char * path_env;
  path_env = getenv("PATH");
  while (1) {
    printf("$");
    fflush(stdout);
    if (fgets(command, MAX_LINE, stdin) == NULL)
      break;
    command[strcspn(command, "\n")] = '\0';
    int i = 0;
    tokens[i] = strtok(command, " ");
    while (tokens[i] != NULL && i < MAX_ARGS - 1)
      tokens[++i] = strtok(NULL, " ");
    tokens[i] = NULL;
    input = 0;
    output = 1;
    for (i = 0; tokens[i] != NULL; i++) {
      if (strcmp(tokens[i], "<") == 0) {
        input = open(tokens[i + 1], O_RDONLY);
        tokens[i] = NULL;
        tokens[i + 1] = NULL;
      } else if (strcmp(tokens[i], ">") == 0) {
        output = open(tokens[i + 1], O_WRONLY | O_CREAT | O_TRUNC,

          0644);

        tokens[i] = NULL;
        tokens[i + 1] = NULL;
      }
    }
    pid_t pid = fork();
    if (pid == 0) {
      if (input != 0) {
        dup2(input, 0);
        close(input);
      }
      if (output != 1) {
        dup2(output, 1);
        close(output);
      }
      if (strchr(tokens[0], '/') == NULL) {
        char * path_copy = strdup(path_env);
        char * path_token = strtok(path_copy, ":");
        while (path_token != NULL) {
          char * command_path = malloc(strlen(path_token) +

            strlen(tokens[0]) + 2);

          sprintf(command_path, "%s/%s", path_token, tokens[0]);
          if (access(command_path, X_OK) == 0) {
            tokens[0] = command_path;
            break;
          }
          free(command_path);
          path_token = strtok(NULL, ":");
        }
        free(path_copy);
      }
      // Execute the command
      execvp(tokens[0], tokens);
      perror("execvp");
      exit(1);
    } else {
      perror("fork");
    }
  }
  return 0;
}



/*
Program to implement context switching
*/

#include <ucontext.h>  
#include <stdio.h>     
#include <stdlib.h>    
#include <unistd.h>    

#define MAXTASKS 3    //denotes number of tasks

#define STACK_SIZE 1024 * 64  // stack memory 

// We will store each task's context in this array
ucontext_t contexts[MAXTASKS];

void taskA(void) {
        printf("taskA running......\n");
        sleep(2);  // Wait for 2 seconds
        printf("Switching to taskB.....\n");
        sleep(1);
        swapcontext(&contexts[0],&contexts[1]);  // Move execution to taskB after saving state of current context
        
        printf("Resuming taskA....\n");
        sleep(1);
        
        swapcontext(&contexts[0],&contexts[2]);
}

void taskB(void) {
    printf("taskB running......\n");
        sleep(2);  // Wait for 2 seconds  
        printf("Switching to taskC.....\n");
        sleep(1);
        swapcontext(&contexts[1],&contexts[2]);  // Move execution to taskC after saving state of current context
}

void taskC(void) {
    printf("taskC running......\n");
    sleep(2);  // Wait for 2 seconds
    swapcontext(&contexts[2],&contexts[0]);   // Move execution to taskA to resume its execution, after saving state of current context
    
    printf("Program Ends....\n");
    exit(0);  // End the program here
}


// uc is a pointer to the context (where the state of the task is saved)
// func is the function the task will execute (e.g., taskA, taskB)
void init_context(ucontext_t *uc, void (*func)(void)) {
    void *stack = malloc(STACK_SIZE);  // Allocating  memory for the stack
    getcontext(uc);                    // get current context 
    uc->uc_stack.ss_sp = stack;        // set stack pointer
    uc->uc_stack.ss_size = STACK_SIZE; // set stack size
    uc->uc_stack.ss_flags = 0;         // set flags, here we don't need this so 0
    makecontext(uc, func, 0);          // linking func to this context
}

int main() {
    // Initialize the contexts
    for (int i = 0; i < MAXTASKS; i++) {
        switch (i) {
            case 0: init_context(&contexts[i], taskA); break;  
            case 1: init_context(&contexts[i], taskB); break;  
            case 2: init_context(&contexts[i], taskC); break;  
        }
    }

    // Start execution with taskA
    setcontext(&contexts[0]);

    return 0;   
}






#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <stdbool.h>
#include <math.h>

#define MAX_LIMIT 100 // Upper limit for the sieve
#define NUM_THREADS 4     // Number of threads

bool is_prime[MAX_LIMIT + 1];  // Array to mark prime numbers
pthread_mutex_t lock;          // Mutex lock for synchronization

// Thread function to mark non-prime numbers
void* mark_non_primes(void* arg) {
    int thread_id = (long)arg;  // Thread ID passed as argument
    printf("Thread %d created....\n",thread_id);
    int segment_size = MAX_LIMIT / NUM_THREADS;
    int start = thread_id * segment_size + 1;
    int end = (thread_id == NUM_THREADS - 1) ? MAX_LIMIT : (thread_id + 1) * segment_size;
    printf("Striking between %d - %d..... \n",start,end);
    for (int i = 2; i * i <= MAX_LIMIT; i++) {
        if (is_prime[i]) {
            // Calculate the first multiple of i in the current segment
            int j = (start + i - 1) / i * i;
            if (j < i * i) j = i * i;  // Ensure we start from i*i

            // Mark multiples of i as non-prime
            for (; j <= end; j += i) {
                pthread_mutex_lock(&lock);  // Lock before updating shared array
                is_prime[j] = false;
                pthread_mutex_unlock(&lock);  // Unlock after updating
            }
        }
    }
    sleep(2);
    printf("Thread %d ended....\n",thread_id);
    pthread_exit(NULL);
}

void sieve_of_eratosthenes_pthreads() {
    // Initialize the is_prime array
    for (int i = 0; i <= MAX_LIMIT; i++) {
        is_prime[i] = true;
    }
    is_prime[0] = is_prime[1] = false;  // 0 and 1 are not prime

    // Create threads
    pthread_t threads[NUM_THREADS];
    pthread_mutex_init(&lock, NULL);

    // Create NUM_THREADS threads, passing the thread ID as argument
    for (long i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, mark_non_primes, (void*)i);
    }

    // Wait for all threads to finish
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&lock);

    // Print prime numbers
    printf("Prime numbers up to %d are:\n", MAX_LIMIT);
    for (int i = 2; i <= MAX_LIMIT; i++) {
        if (is_prime[i]) {
            printf("%d ", i);
        }
    }
    printf("\n");
}

int main() {
    sieve_of_eratosthenes_pthreads();
    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define SIZE 8192		/* Size of matrices */
int N;				/* number of threads */
//int thread_args[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
int thread_args[64] = {0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10, 11, 12, 13, 14, 15,
                16, 17, 18, 19 ,20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
                32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
                48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};


int A[SIZE][SIZE], B[SIZE][SIZE], C[SIZE][SIZE];
//pthread_barrier_t barr;

void fill_matrix(int m[SIZE][SIZE])
{
	int i, j, n = 0;

	for (i=0; i<SIZE; i++)
		for (j=0; j<SIZE; j++)
			m[i][j] = n++;
}



void* mmult (void* slice)
{
	int s = *(int *)slice;
	int from = (s * SIZE)/N;	/* note that this 'slicing' works fine */
	int to = ((s+1) * SIZE)/N;	/* even if SIZE is not divisible by N */
	int i,j,k;

//	pthread_barrier_wait(&barr);
	printf("computing slice %d (from row %d to %d)\n", s, from, to-1);
	for (i=from; i<to; i++)
	{
		if (i % 10 == 0)
			//printf("Computing: %d\n",i); 
		for (j=0; j<SIZE; j++) {
			C[i][j]=0;
			for (k=0; k<SIZE; k++)
				C[i][j] += A[i][k]*B[k][j];
		}
	}

	printf("finished slice %d\n", s);
	return 0;
}

int main(int argc, char *argv[])
{
	pthread_t thread[64];
	int i, mcmodel;
	int t1, t2, t3, t4;

	if (argc!=2) {
		printf("Usage: %s <NPROC>\n",argv[0]);
		exit(-1);
	}  

	N=atoi(argv[1]);
	fill_matrix(A);
	fill_matrix(B);
//	pthread_barrier_init(&barr, NULL, N);
	t1 = time(NULL);
	for (i=1; i<N; i++) {
		if (pthread_create (&thread[i], NULL, mmult, (void*)&thread_args[i]) != 0 ) {
			printf("Can't create thread");
			exit(-1);
		}
	}

	/* master thread is thread 0 so: */
	t2 = time(NULL);
	mmult(&thread_args[0]);
	t3 = time(NULL);
	//printf("Waiting for the child threads\n");
	for (i=1; i<N; i++) pthread_join (thread[i], NULL);
	t4 = time(NULL);

	printf("Time elapsed : creation %d, multipliction : %d, joining : %d\n", t2-t1, t3-t2, t4-t3);
	return 0;
}




/*
	PRODUCER CONSUMER PROBLEM
*/

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#define BUFFER_SIZE 20
#define num 3

int buffer[BUFFER_SIZE];
int counter = 0;

pthread_mutex_t mutex;
sem_t fillCount, emptyCount;

pthread_t producer[num];
pthread_t consumer[num];

void *producer_work(void *arg)
{
    int n = *(int *)arg;
    int i;
    while (1)
    {
        // produceItem
        sem_wait(&emptyCount);
        pthread_mutex_lock(&mutex);
        printf("\nProducer[%d] has put an item in buffer[%d]", n, counter);
        buffer[counter] = n; // putting its own id
        for (i = 0; i < 0x2000000; i++)
            ; // it is writing to buffer
        counter++;
        pthread_mutex_unlock(&mutex);
        sem_post(&fillCount);
    }
}

void *consumer_work(void *arg)
{
    int n = *(int *)arg;
    int i;
    while (1)
    {
        sem_wait(&fillCount);
        pthread_mutex_lock(&mutex);
        printf("\nConsumer[%d] has removed an item from buffer[%d]", n, counter - 1);
        counter--;
        for (i = 0; i < 0x2000000; i++)
            ;
        pthread_mutex_unlock(&mutex);
        sem_post(&emptyCount);
    }
}

void main()
{
    // initialize
    pthread_mutex_init(&mutex, NULL);
    sem_init(&fillCount, 0, 0);
    sem_init(&emptyCount, 0, BUFFER_SIZE);
    counter = 0;

    int i, ret;
    int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    for (i = 0; i < num; i++)
    {
        ret = pthread_create(&producer[i], NULL, producer_work, (void *)&arr[i]);
        if (ret != 0)
            printf("Error in creating producer no %d :", i);
    }

    for (i = 0; i < num; i++)
    {
        ret = pthread_create(&consumer[i], NULL, consumer_work, (void *)&arr[i]);
        if (ret != 0)
            printf("Error in creating consumer no %d :", i);
    }

    for (i = 0; i < num; i++)
    {
        pthread_join(producer[i], NULL);
        pthread_join(consumer[i], NULL);
    }
}



#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5
int buffer[BUFFER_SIZE];//Producer produces and places it in buffer, so that consumer can consume it.
int in = 0, out = 0;
pthread_mutex_t mutex;
pthread_cond_t not_empty, not_full;

void* producer(void* arg) {
    for (int i = 0; i < 5; i++) {
        pthread_mutex_lock(&mutex);

        while ((in + 1) % BUFFER_SIZE == out) {
            pthread_cond_wait(&not_full, &mutex);
        }

        buffer[in] = i; // Produce an item
        printf("Produced Item: %d\n", buffer[in]);
        in = (in + 1) % BUFFER_SIZE;

        pthread_cond_signal(&not_empty);
        pthread_mutex_unlock(&mutex);
        sleep(3);
    }
    return NULL;
}

void* consumer(void* arg) {
    for (int i = 0; i < 10; i++) {
        pthread_mutex_lock(&mutex);

        while (in == out) {
            pthread_cond_wait(&not_empty, &mutex);
        }

        int item = buffer[out]; // Consume an item
        printf("Consumed Item: %d\n", item);
        out = (out + 1) % BUFFER_SIZE;

        pthread_cond_signal(&not_full);
        pthread_mutex_unlock(&mutex);
        sleep(3);
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;
    pthread_mutex_init(&mutex, NULL);//Intializing the mutex
    pthread_cond_init(&not_empty, NULL);//Intializng the Conditional Variables
    pthread_cond_init(&not_full, NULL);

    pthread_create(&prod, NULL, producer, NULL);//Creating Thread for Producer
    pthread_create(&cons, NULL, consumer, NULL);// Creating Thread for Consumer

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&not_empty);
    pthread_cond_destroy(&not_full);
    return 0;
}

/*
Reader Writer Problem
*/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t reading_mutex;
pthread_mutex_t writing_mutex;
int read_count = 0;

void* reader(void* id) {
    int reader_id = *(int*)id;
    while (1) {
        pthread_mutex_lock(&reading_mutex);
        read_count++;
        if (read_count == 1) {
            pthread_mutex_lock(&writing_mutex); // First reader locks the writer
        }
        pthread_mutex_unlock(&reading_mutex);

        // Reading section
        printf("Reader %d is reading.\n", reader_id);
        usleep(3);
        
        pthread_mutex_lock(&reading_mutex);
        read_count--;
        if (read_count == 0) {
            pthread_mutex_unlock(&writing_mutex); // Last reader unlocks the writer
        }
        pthread_mutex_unlock(&reading_mutex);
        usleep(3);
    }
    return NULL;
}

void* writer(void* id) {
    int writer_id = *(int*)id;
    while (1) {
        pthread_mutex_lock(&writing_mutex); // Exclusive access to write
        printf("Writer %d is writing.\n", writer_id);
        usleep(4);
        pthread_mutex_unlock(&writing_mutex);
        usleep(4);
    }
    return NULL;
}

int main() {
    pthread_t readers[5], writers[2];
    int ids[5] = {0, 1, 2, 3, 4};
    int writer_ids[2] = {0, 1};

    pthread_mutex_init(&reading_mutex, NULL);
    pthread_mutex_init(&writing_mutex, NULL);

    for (int i = 0; i < 5; i++) {
        pthread_create(&readers[i], NULL, reader, &ids[i]);
    }
    
    for (int i = 0; i < 2; i++) {
        pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(readers[i], NULL);
    }
    
    for (int i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
    }

    pthread_mutex_destroy(&reading_mutex);
    pthread_mutex_destroy(&writing_mutex);
    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define NUM_PHILOSOPHERS 5
pthread_mutex_t chopSticks[NUM_PHILOSOPHERS];
pthread_mutex_t lock;

void* philosopher(void* num) {
    int id = *(int*)num;
    while (1) {
        printf("Philosopher %d is thinking.\n", id);
        usleep(2);
        
        pthread_mutex_lock(&lock);
        pthread_mutex_lock(&chopSticks[id]); // Pick up left fork
        pthread_mutex_lock(&chopSticks[(id + 1) % NUM_PHILOSOPHERS]); // Pick up right fork
        
        printf("Philosopher %d is eating.\n", id);
        usleep(3);
        
        pthread_mutex_unlock(&chopSticks[id]); // Put down left fork
        pthread_mutex_unlock(&chopSticks[(id + 1) % NUM_PHILOSOPHERS]); // Put down right fork
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}

int main() {
    pthread_t philosophers[NUM_PHILOSOPHERS];
    int ids[NUM_PHILOSOPHERS];

    pthread_mutex_init(&lock, NULL);
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_mutex_init(&chopSticks[i], NULL);
        ids[i] = i;
    }

    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_create(&philosophers[i], NULL, philosopher, &ids[i]);
    }

    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_join(philosophers[i], NULL);
    }

    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_mutex_destroy(&chopSticks[i]);
    }
    pthread_mutex_destroy(&lock);
    return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define CHAIRS 5
pthread_mutex_t mutex;
pthread_cond_t barberReady;
pthread_cond_t customerReady;
int waitingCustomers = 0;

void* barber(void* arg) {
    while (1) {
        pthread_mutex_lock(&mutex);
        while (waitingCustomers == 0) {
            pthread_cond_wait(&customerReady, &mutex);
        }
        
        waitingCustomers--;
        printf("Barber is cutting hair. Waiting customers: %d\n", waitingCustomers);
        pthread_mutex_unlock(&mutex);

        sleep(2); // Simulate haircut
        pthread_cond_signal(&barberReady);
    }
    return NULL;
}

void* customer(void* arg) {
while(1){
    pthread_mutex_lock(&mutex);
    if (waitingCustomers < CHAIRS) {
        waitingCustomers++;
        printf("Customer arrived. Waiting customers: %d\n", waitingCustomers);
        pthread_cond_signal(&customerReady);
        pthread_mutex_unlock(&mutex);
        pthread_cond_wait(&barberReady, &mutex); // Wait for barber to be ready
        printf("Customer getting a haircut.\n");
    } else {
        printf("Customer leaving. No chairs available.\n");
        pthread_mutex_unlock(&mutex);
    }
}
    return NULL;
}

int main() {
    pthread_t barberThread, customerThreads[10];

    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&barberReady, NULL);
    pthread_cond_init(&customerReady, NULL);

    pthread_create(&barberThread, NULL, barber, NULL);
    
    for (int i = 0; i < 10; i++) {
        pthread_create(&customerThreads[i], NULL, customer, NULL);
        sleep(3);
    }

    pthread_join(barberThread, NULL);
    for (int i = 0; i < 10; i++) {
        pthread_join(customerThreads[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&barberReady);
    pthread_cond_destroy(&customerReady);
    return 0;
}








#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 10
#define STACK_SIZE 1024 * 64

typedef struct thread
{
    ucontext_t context;  // Thread's context
    int id;              // Thread ID
    int active;          // Is the thread active
    int arrival_time;    // Arrival time of the thread
    int burst_time;      // Burst time (execution time) of the thread
    int remaining_time;  // Remaining burst time
    int start_time;      // Start time when the thread starts execution
    int completion_time; // Completion time when the thread finishes execution
} thread_t;

static thread_t *threads[MAX_THREADS]; // Thread table
static int current_thread = -1;        // Currently running thread
static int thread_count = 0;           // Total number of threads
static int current_time = 0;           // Simulated time

// Function to create a new thread
int thread_create(void (*function)(void *), void *arg, int arrival_time, int burst_time)
{
    if (thread_count >= MAX_THREADS)
        return -1;

    // Allocate memory for the new thread
    thread_t *t = malloc(sizeof(thread_t));
    if (!t)
        return -1;

    t->id = thread_count++;
    t->active = 1;
    t->arrival_time = arrival_time;
    t->burst_time = burst_time;
    t->remaining_time = burst_time;
    t->start_time = -1;
    t->completion_time = -1;

    // Initialize the context for the thread
    if (getcontext(&t->context) == -1)
        return -1;

    t->context.uc_stack.ss_sp = malloc(STACK_SIZE);
    if (!t->context.uc_stack.ss_sp)
        return -1;

    t->context.uc_stack.ss_size = STACK_SIZE;
    t->context.uc_link = NULL;

    makecontext(&t->context, (void (*)(void))function, 1, arg);
    threads[t->id] = t;
    return t->id;
}

// FCFS scheduler
void thread_scheduler(int signum)
{
    int next_thread = -1;
    for (int i = 0; i < thread_count; i++)
    {
        if (threads[i]->active && threads[i]->arrival_time <= current_time)
        {
            if (next_thread == -1 || threads[i]->arrival_time < threads[next_thread]->arrival_time)
            {
                next_thread = i;
            }
        }
    }

    if (next_thread == -1)
    {
        current_time++;
        return;
    }

    int prev_thread = current_thread;
    current_thread = next_thread;

    if (threads[current_thread]->remaining_time == threads[current_thread]->burst_time)
    {
        threads[current_thread]->start_time = current_time;
        printf("Thread %d is running (Arrival: %d, Burst: %d, Start: %d)\n",
               threads[current_thread]->id, threads[current_thread]->arrival_time,
               threads[current_thread]->burst_time, threads[current_thread]->start_time);
    }

    current_time += threads[current_thread]->remaining_time;
    threads[current_thread]->remaining_time = 0;

    if (threads[current_thread]->remaining_time <= 0)
    {
        threads[current_thread]->completion_time = current_time;
        printf("Thread %d has finished execution. Completion time: %d\n",
               threads[current_thread]->id, threads[current_thread]->completion_time);
        threads[current_thread]->active = 0;
        free(threads[current_thread]->context.uc_stack.ss_sp);
        threads[current_thread]->context.uc_stack.ss_sp = NULL;
    }

    if (prev_thread == -1 || !threads[prev_thread]->active)
    {
        setcontext(&threads[current_thread]->context);
    }
    else
    {
        swapcontext(&threads[prev_thread]->context, &threads[current_thread]->context);
    }
}

// Exit the current thread
void thread_exit()
{
    threads[current_thread]->active = 0;
    free(threads[current_thread]->context.uc_stack.ss_sp);
    threads[current_thread]->context.uc_stack.ss_sp = NULL;
    thread_scheduler(0);
}

// Setup the timer for scheduling
void setup_timer()
{
    struct itimerval timer;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = 1000;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = 1000;

    setitimer(ITIMER_REAL, &timer, NULL);
    signal(SIGALRM, thread_scheduler);
}

// Test function to simulate thread work
void test_function(void *arg)
{
    int id = *((int *)arg);
    sleep(1);
    thread_exit();
}

int main()
{
    setup_timer();
    srand(time(NULL));

    int thread_ids[MAX_THREADS];
    for (int i = 0; i < MAX_THREADS; i++)
    {
        int arrival_time = rand() % 10;
        int burst_time = (rand() % 5) + 1;
        thread_create(test_function, &thread_ids[i], arrival_time, burst_time);
        printf("Created thread %d (Arrival: %d, Burst: %d)\n", i, arrival_time, burst_time);
    }

    while (1)
    {
        pause();
    }

    return 0;
}



#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 10
#define STACK_SIZE 1024 * 64

typedef struct thread
{
    ucontext_t context;  // Thread's context
    int id;              // Thread ID
    int active;          // Is the thread active
    int arrival_time;    // Arrival time of the thread
    int burst_time;      // Burst time (execution time) of the thread
    int remaining_time;  // Remaining burst time
    int start_time;      // Start time when the thread starts execution
    int completion_time; // Completion time when the thread finishes execution
} thread_t;

static thread_t *threads[MAX_THREADS]; // Thread table
static int current_thread = -1;        // Currently running thread
static int thread_count = 0;           // Total number of threads
static int current_time = 0;           // Simulated time

// Function to create a new thread
int thread_create(void (*function)(void *), void *arg, int arrival_time, int burst_time)
{
    if (thread_count >= MAX_THREADS)
        return -1;

    // Allocate memory for the new thread
    thread_t *t = malloc(sizeof(thread_t));
    if (!t)
        return -1;

    t->id = thread_count++;
    t->active = 1;
    t->arrival_time = arrival_time;
    t->burst_time = burst_time;
    t->remaining_time = burst_time;
    t->start_time = -1;
    t->completion_time = -1;

    // Initialize the context for the thread
    if (getcontext(&t->context) == -1)
        return -1;

    t->context.uc_stack.ss_sp = malloc(STACK_SIZE);
    if (!t->context.uc_stack.ss_sp)
        return -1;

    t->context.uc_stack.ss_size = STACK_SIZE;
    t->context.uc_link = NULL;

    makecontext(&t->context, (void (*)(void))function, 1, arg);
    threads[t->id] = t;
    return t->id;
}

// FCFS scheduler
void thread_scheduler(int signum)
{
    int next_thread = -1;
    for (int i = 0; i < thread_count; i++)
    {
        if (threads[i]->active && threads[i]->arrival_time <= current_time)
        {
            if (next_thread == -1 || threads[i]->arrival_time < threads[next_thread]->arrival_time)
            {
                next_thread = i;
            }
        }
    }

    if (next_thread == -1)
    {
        current_time++;
        return;
    }

    int prev_thread = current_thread;
    current_thread = next_thread;

    if (threads[current_thread]->remaining_time == threads[current_thread]->burst_time)
    {
        threads[current_thread]->start_time = current_time;
        printf("Thread %d is running (Arrival: %d, Burst: %d, Start: %d)\n",
               threads[current_thread]->id, threads[current_thread]->arrival_time,
               threads[current_thread]->burst_time, threads[current_thread]->start_time);
    }

    current_time += threads[current_thread]->remaining_time;
    threads[current_thread]->remaining_time = 0;

    if (threads[current_thread]->remaining_time <= 0)
    {
        threads[current_thread]->completion_time = current_time;
        printf("Thread %d has finished execution. Completion time: %d\n",
               threads[current_thread]->id, threads[current_thread]->completion_time);
        threads[current_thread]->active = 0;
        free(threads[current_thread]->context.uc_stack.ss_sp);
        threads[current_thread]->context.uc_stack.ss_sp = NULL;
    }

    if (prev_thread == -1 || !threads[prev_thread]->active)
    {
        setcontext(&threads[current_thread]->context);
    }
    else
    {
        swapcontext(&threads[prev_thread]->context, &threads[current_thread]->context);
    }
}

// Exit the current thread
void thread_exit()
{
    threads[current_thread]->active = 0;
    free(threads[current_thread]->context.uc_stack.ss_sp);
    threads[current_thread]->context.uc_stack.ss_sp = NULL;
    thread_scheduler(0);
}

// Setup the timer for scheduling
void setup_timer()
{
    struct itimerval timer;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = 1000;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = 1000;

    setitimer(ITIMER_REAL, &timer, NULL);
    signal(SIGALRM, thread_scheduler);
}

// Test function to simulate thread work
void test_function(void *arg)
{
    int id = *((int *)arg);
    sleep(1);
    thread_exit();
}

int main()
{
    setup_timer();
    srand(time(NULL));

    int thread_ids[MAX_THREADS];
    for (int i = 0; i < MAX_THREADS; i++)
    {
        int arrival_time = rand() % 10;
        int burst_time = (rand() % 5) + 1;
        thread_create(test_function, &thread_ids[i], arrival_time, burst_time);
        printf("Created thread %d (Arrival: %d, Burst: %d)\n", i, arrival_time, burst_time);
    }

    while (1)
    {
        pause();
    }

    return 0;
}






#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 10
#define STACK_SIZE 1024 * 64

typedef struct thread
{
    ucontext_t context;
    int id;
    int active;
    int arrival_time;
    int burst_time;
    int start_time;
    int completion_time;
} thread_t;

static thread_t *threads[MAX_THREADS];
static int current_thread = -1;
static int thread_count = 0;
static int current_time = 0;

int thread_create(void (*function)(void *), void *arg, int arrival_time, int burst_time)
{
    if (thread_count >= MAX_THREADS)
        return -1;

    thread_t *t = malloc(sizeof(thread_t));
    if (!t)
        return -1;

    t->id = thread_count++;
    t->active = 1;
    t->arrival_time = arrival_time;
    t->burst_time = burst_time;
    t->start_time = -1;
    t->completion_time = -1;

    if (getcontext(&t->context) == -1)
        return -1;

    t->context.uc_stack.ss_sp = malloc(STACK_SIZE);
    if (!t->context.uc_stack.ss_sp)
        return -1;

    t->context.uc_stack.ss_size = STACK_SIZE;
    t->context.uc_link = NULL;

    makecontext(&t->context, (void (*)(void))function, 1, arg);
    threads[t->id] = t;
    return t->id;
}

// SJF scheduler
void sjf_scheduler()
{
    int next_thread = -1;

    while (1)
    {
        for (int i = 0; i < thread_count; i++)
        {
            if (threads[i]->active && threads[i]->arrival_time <= current_time)
            {
                if (next_thread == -1 || threads[i]->burst_time < threads[next_thread]->burst_time)
                {
                    next_thread = i;
                }
            }
        }

        if (next_thread == -1)
        {
            current_time++;
            continue;
        }

        threads[next_thread]->start_time = current_time;
        printf("Thread %d is running (Arrival: %d, Burst: %d, Start: %d)\n",
               threads[next_thread]->id, threads[next_thread]->arrival_time,
               threads[next_thread]->burst_time, threads[next_thread]->start_time);

        current_time += threads[next_thread]->burst_time;
        threads[next_thread]->completion_time = current_time;
        printf("Thread %d has finished execution. Completion time: %d\n",
               threads[next_thread]->id, threads[next_thread]->completion_time);
        threads[next_thread]->active = 0;

        free(threads[next_thread]->context.uc_stack.ss_sp);
        threads[next_thread]->context.uc_stack.ss_sp = NULL;

        next_thread = -1;
    }
}

void thread_exit()
{
    threads[current_thread]->active = 0;
}

void test_function(void *arg)
{
    sleep(1);
    thread_exit();
}

int main()
{
    srand(time(NULL));

    int thread_ids[MAX_THREADS];
    for (int i = 0; i < MAX_THREADS; i++)
    {
        int arrival_time = rand() % 10;
        int burst_time = (rand() % 5) + 1;
        thread_create(test_function, &thread_ids[i], arrival_time, burst_time);
        printf("Created thread %d (Arrival: %d, Burst: %d)\n", i, arrival_time, burst_time);
    }

    sjf_scheduler();
    return 0;
}




#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 10
#define STACK_SIZE 1024 * 64

typedef struct thread
{
    ucontext_t context;
    int id;
    int active;
    int arrival_time;
    int burst_time;
    int remaining_time;
    int start_time;
    int completion_time;
} thread_t;

static thread_t *threads[MAX_THREADS];
static int current_thread = -1;
static int thread_count = 0;
static int current_time = 0;

int thread_create(void (*function)(void *), void *arg, int arrival_time, int burst_time)
{
    if (thread_count >= MAX_THREADS)
        return -1;

    thread_t *t = malloc(sizeof(thread_t));
    if (!t)
        return -1;

    t->id = thread_count++;
    t->active = 1;
    t->arrival_time = arrival_time;
    t->burst_time = burst_time;
    t->remaining_time = burst_time;
    t->start_time = -1;
    t->completion_time = -1;

    if (getcontext(&t->context) == -1)
        return -1;

    t->context.uc_stack.ss_sp = malloc(STACK_SIZE);
    if (!t->context.uc_stack.ss_sp)
        return -1;

    t->context.uc_stack.ss_size = STACK_SIZE;
    t->context.uc_link = NULL;

    makecontext(&t->context, (void (*)(void))function, 1, arg);
    threads[t->id] = t;
    return t->id;
}

// SRTF scheduler
void srtf_scheduler()
{
    int next_thread = -1;

    while (1)
    {
        for (int i = 0; i < thread_count; i++)
        {
            if (threads[i]->active && threads[i]->arrival_time <= current_time)
            {
                if (next_thread == -1 || threads[i]->remaining_time < threads[next_thread]->remaining_time)
                {
                    next_thread = i;
                }
            }
        }

        if (next_thread == -1)
        {
            current_time++;
            continue;
        }

        if (threads[next_thread]->start_time == -1)
        {
            threads[next_thread]->start_time = current_time;
            printf("Thread %d is running (Arrival: %d, Burst: %d, Start: %d)\n",
                   threads[next_thread]->id, threads[next_thread]->arrival_time,
                   threads[next_thread]->burst_time, threads[next_thread]->start_time);
        }

        current_time++;
        threads[next_thread]->remaining_time--;

        if (threads[next_thread]->remaining_time <= 0)
        {
            threads[next_thread]->completion_time = current_time;
            printf("Thread %d has finished execution. Completion time: %d\n",
                   threads[next_thread]->id, threads[next_thread]->completion_time);
            threads[next_thread]->active = 0;

            free(threads[next_thread]->context.uc_stack.ss_sp);
            threads[next_thread]->context.uc_stack.ss_sp = NULL;
        }

        next_thread = -1;
    }
}

void thread_exit()
{
    threads[current_thread]->active = 0;
}

void test_function(void *arg)
{
    sleep(1);
    thread_exit();
}

int main()
{
    srand(time(NULL));

    int thread_ids[MAX_THREADS];
    for (int i = 0; i < MAX_THREADS; i++)
    {
        int arrival_time = rand() % 10;
        int burst_time = (rand() % 5) + 1;
        thread_create(test_function, &thread_ids[i], arrival_time, burst_time);
        printf("Created thread %d (Arrival: %d, Burst: %d)\n", i, arrival_time, burst_time);
    }

    srtf_scheduler();
    return 0;
}





#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BLOCK_SIZE 512
#define MAX_FILES 128
#define MAX_FILE_NAME 255
#define MAX_FILE_SIZE 1024 * 10  // 10 KB per file max

// File system structure
typedef struct {
    unsigned int total_blocks;
    unsigned int free_blocks;
    unsigned int block_size;
} Superblock;

typedef struct {
    unsigned int size;          // File size in bytes
    unsigned int block_index;   // Index to the block in disk
    unsigned int is_used;       // Used or not (1 for used, 0 for free)
} Inode;

typedef struct {
    char file_name[MAX_FILE_NAME];
    unsigned int inode_index;  // Index of the inode
} DirectoryEntry;

typedef struct {
    Superblock superblock;
    Inode inodes[MAX_FILES];
    DirectoryEntry directory[MAX_FILES];
    char disk_image[BLOCK_SIZE * 100];  // Simulate a disk image (100 blocks max)
} FileSystem;

// Function prototypes
int init_fs(FileSystem* fs);
int create_file(FileSystem* fs, const char* file_name, const char* content);
int write_to_file(FileSystem* fs, const char* file_name, const char* content);
int read_from_file(FileSystem* fs, const char* file_name, char* buffer, size_t buffer_size);
int delete_file(FileSystem* fs, const char* file_name);
int list_files(FileSystem* fs);

int main() {
    FileSystem fs;

    // Initialize file system
    init_fs(&fs);

    // Create a file
    create_file(&fs, "file1.txt", "Hello, world!");

    // Write to a file
    write_to_file(&fs, "file1.txt", "Hello, this is an updated content.");

    // Read from a file
    char buffer[MAX_FILE_SIZE];
    read_from_file(&fs, "file1.txt", buffer, sizeof(buffer));
    printf("File content: %s\n", buffer);

    // List files
    list_files(&fs);

    // Delete a file
    delete_file(&fs, "file1.txt");

    return 0;
}

// Initialize the file system
int init_fs(FileSystem* fs) {
    memset(fs, 0, sizeof(FileSystem));  // Zero out the file system
    fs->superblock.total_blocks = 100;  // Total 100 blocks
    fs->superblock.free_blocks = 100;   // Initially all blocks are free
    fs->superblock.block_size = BLOCK_SIZE;

    // Mark all inodes as unused
    for (int i = 0; i < MAX_FILES; i++) {
        fs->inodes[i].is_used = 0;
    }

    return 0;
}

// Create a file in the file system
int create_file(FileSystem* fs, const char* file_name, const char* content) {
    if (fs->superblock.free_blocks == 0) {
        printf("Error: No free blocks available.\n");
        return -1;
    }

    // Find an unused inode
    int inode_index = -1;
    for (int i = 0; i < MAX_FILES; i++) {
        if (fs->inodes[i].is_used == 0) {
            inode_index = i;
            break;
        }
    }

    if (inode_index == -1) {
        printf("Error: No free inodes available.\n");
        return -1;
    }

    // Allocate a block for the file content
    int block_index = fs->superblock.total_blocks - fs->superblock.free_blocks;
    fs->superblock.free_blocks--;
    fs->inodes[inode_index].block_index = block_index;
    fs->inodes[inode_index].size = strlen(content);
    fs->inodes[inode_index].is_used = 1;

    // Store content in the simulated disk image
    strncpy(&fs->disk_image[block_index * BLOCK_SIZE], content, BLOCK_SIZE);

    // Add file to the directory
    DirectoryEntry* entry = &fs->directory[inode_index];
    strncpy(entry->file_name, file_name, MAX_FILE_NAME);
    entry->inode_index = inode_index;

    printf("File '%s' created successfully.\n", file_name);
    return 0;
}

// Write to an existing file
int write_to_file(FileSystem* fs, const char* file_name, const char* content) {
    // Find the file's inode index
    int inode_index = -1;
    for (int i = 0; i < MAX_FILES; i++) {
        if (strcmp(fs->directory[i].file_name, file_name) == 0) {
            inode_index = fs->directory[i].inode_index;
            break;
        }
    }

    if (inode_index == -1) {
        printf("Error: File not found.\n");
        return -1;
    }

    Inode* inode = &fs->inodes[inode_index];
    if (inode->is_used == 0) {
        printf("Error: File is not in use.\n");
        return -1;
    }

    // Write content to the disk image
    strncpy(&fs->disk_image[inode->block_index * BLOCK_SIZE], content, BLOCK_SIZE);
    inode->size = strlen(content);  // Update file size
    printf("Content written to '%s'.\n", file_name);
    return 0;
}

// Read from an existing file
int read_from_file(FileSystem* fs, const char* file_name, char* buffer, size_t buffer_size) {
    // Find the file's inode index
    int inode_index = -1;
    for (int i = 0; i < MAX_FILES; i++) {
        if (strcmp(fs->directory[i].file_name, file_name) == 0) {
            inode_index = fs->directory[i].inode_index;
            break;
        }
    }

    if (inode_index == -1) {
        printf("Error: File not found.\n");
        return -1;
    }

    Inode* inode = &fs->inodes[inode_index];
    if (inode->is_used == 0) {
        printf("Error: File is not in use.\n");
        return -1;
    }

    // Read file content from the simulated disk image
    strncpy(buffer, &fs->disk_image[inode->block_index * BLOCK_SIZE], buffer_size);
    buffer[buffer_size - 1] = '\0';  // Ensure null-terminated string
    printf("Content read from '%s'.\n", file_name);
    return 0;
}

// Delete a file
int delete_file(FileSystem* fs, const char* file_name) {
    // Find the file's inode index
    int inode_index = -1;
    for (int i = 0; i < MAX_FILES; i++) {
        if (strcmp(fs->directory[i].file_name, file_name) == 0) {
            inode_index = fs->directory[i].inode_index;
            break;
        }
    }

    if (inode_index == -1) {
        printf("Error: File not found.\n");
        return -1;
    }

    Inode* inode = &fs->inodes[inode_index];
    if (inode->is_used == 0) {
        printf("Error: File is not in use.\n");
        return -1;
    }

    // Mark inode as free
    inode->is_used = 0;
    fs->superblock.free_blocks++;
    printf("File '%s' deleted successfully.\n", file_name);
    return 0;
}

// List all files in the file system
int list_files(FileSystem* fs) {
    printf("List of files in the file system:\n");
    for (int i = 0; i < MAX_FILES; i++) {
        if (fs->inodes[i].is_used == 1) {
            printf("%s\n", fs->directory[i].file_name);
        }
    }
    return 0;
}




